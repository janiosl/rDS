geom_line()
#Atraso por minutos de cada hora - agendamento decolagem
flights_dt %>%
mutate(minute = minute(sched_dep_time)) %>%
group_by(minute) %>%
summarize(
avg_delay = mean(arr_delay, na.rm = TRUE),
n = n()
) %>%
ggplot(aes(minute, avg_delay)) +
geom_line()
#Atraso por minutos de cada hora - agendamento decolagem
flights_dt %>%
mutate(minute = minute(sched_dep_time)) %>%
group_by(minute) %>%
summarize(
avg_delay = mean(arr_delay, na.rm = TRUE),
n = n()
) %>%
#ggplot(aes(minute, avg_delay)) +
ggplot(aes(minute, n)) +
geom_line()
?floor_date
#Arredondamento
flights_dt %>%
count(week = floor_date(dep_time, "week")) %>%
ggplot(aes(week, n)) +
geom_line()
#Arredondamento
round_date(
x,
unit = "second",
week_start = getOption("lubridate.week.start", 7)
)
datetime
year(datetime) <- 2023
datetime
month(datetime) <- 1
#Configuração/alteração de componentes
datetime
year(datetime) <- 1981
#Configuração/alteração de componentes
datetime
month(datetime) <- 1
day(datetime) <- 31
#Configuração/alteração de componentes
datetime
datetime
hour(datetime) <- 15
minute(datetime) <- 0
datetime
wday(datetime, label = TRUE, abbr = FALSE)
datetime
wday(datetime, label = TRUE, abbr = FALSE)
uptade(datetime, year = 2007, month = 12, mday = 20, hour = 20, minute = 0)
update(datetime, year = 2007, month = 12, mday = 20, hour = 20, minute = 0)
second(datetime) <- 0
datetime
update(datetime, year = 2007, month = 12, mday = 20,
hour = 20, minute = 0, second = 0)
new_datetime <- update(datetime, year = 2007, month = 12, mday = 20,
hour = 20, minute = 0, second = 0)
new_datetime
1+9+8+1+1+3+1+1+5
3+0
2+0+0+7+1+2+2+0+2+0+0+0
1+7
1+6
7+3
#Atualiza as datas para o início de cada ano
flights_dt %>%
mutate(dep_hour = update(dep_time, yday = 1)) %>%
ggplot(aes(dep_hour)) +
geom_freqpoly(binwidth = 300)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
##==================================
##Intervalos de tempo
##==================================
#Durações
h_age <- today() - ymd(19810131)
h_age
#Usando lubridate
#Sempre calculado em segundos
as.duration(h_age)
1979+37
dseconds(15)
dminutes(10)
dhours(c(12,14))
ddays(0:5)
dweeks(3)
dyears(1)
#Operações
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
tomorrow <- today() + ddays(1)
tomorrow
lastyear <- today() - dyears(1)
lastyear
one_pm <- ymd_hms("2016-03-12 13:00:00",
tz = "America/New_York")
one_pm
one_pm + ddays(1)
#Períodos
#Calculados em tempos "humanos"
one_pm + days(1)
#Construtores
seconds(15)
minutes(10)
hours(c(12,24))
days(7)
months(1:6)
weeks(3)
years(1)
years(1.5)
#Operações com períodos
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)
#Aplicando ao dataset de voos
flights_dt %>%
filter(arr_time < dep_time)
flights_dt
View(flights_dt)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
flights_dt %>%
filter(overnight, arr_time < dep_time)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
#Intervalos
dyears(1) / ddays(365)
years(1) / days(1)
next_year <- today() + years(1)
next_year
(today() %--% next_year) / ddays(1)
(today() %--% next_year) / days(1)
(today() %--% next_year) %/% days(1)
length(OlsonNames())
library(magrittr)
foo_foo <- litle_bunny()
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
pryr::object_size(diamonds)
install.packages("pryr")
#install.packages("pryr")
pryr::object_size(diamonds)
pryr::object_size(diamonds2)
pryr::object_size(diamonds, diamonds2)
View(diamonds)
View(diamonds2)
diamonds$carat[1] <- NA
#install.packages("pryr")
pryr::object_size(diamonds)
pryr::object_size(diamonds2)
pryr::object_size(diamonds, diamonds2)
##Problema no uso de pipe
#Funções que usam ambiente temporário
assign(x, 10)
##Problema no uso de pipe
#Funções que usam ambiente temporário
assign("x", 10)
x
"x" %>% assign(100)
x
#Definição explícita do ambiente
env <- environment()
"x" <- assign(100)
x
"x" <- assign(100, envir = env)
"x" %>% assign(100, envir = env)
x
#Funções com lazy evaluation
tryCatch(stop("!"), error = function(e) "An error")
stop("!") %>%
tryCatch(error = function(e) "An error")
stop("!") %>%
tryCatch(error = function(e) "An error")
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnomr(100)
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100)
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100) %>%
matrix(ncol = 2)
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100) %>%
matrix(ncol = 2) %>%
plot()
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100) %>%
matrix(ncol = 2) %>%
plot() %>%
str()
#Com Tee %T%
rnorm(100) %>%
matrix(ncol = 2) %T%
plot() %>%
str()
#Com Tee %T%
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot() %>%
str()
?cor
mtcars %$%
cor(disp, mpg)
#Atribuição direta
#Explícita
mtcars <- mtcars %>%
transform(cyl = cyl * 2)
mtcars
#Direta (implícita)
mtcars %<>% transform(cyl = cyl * 2)
mtcars
source("D:/GitHub/rDS/r4ds/rds_cap14_pipes.R", echo=TRUE)
View(mtcars)
source("D:/GitHub/rDS/r4ds/rds_cap14_pipes.R", echo=TRUE)
df <- tibble::tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
df
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
View(df)
#Reescalar uma coluna para rage 0 a 1
df$a <- (df$a - min(df$a, na.rm = TRUE)) /
(max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df
##Abordagem usando função
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
rescale01(df$a)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
df$b_ <- rescale01(df$b)
df
df$c_ <- rescale01(df$c)
df$d_ <- rescale01(df$d)
df
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
#Correção de erros uma única vez
x <- c(1:1), Inf
#Correção de erros uma única vez
x <- c(1:10, Inf)
x
rescale01(x)
##Abordagem usando função
rescale01 <- function(x) {
#Sem tratamento de infinito
#rng <- range(x, na.rm = TRUE)
#Com tratamento de infinito
rng <- range(x, na.rm = TRUE, finite = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
#Repetição após tratamento do erro na função
rescale01(x)
?'if'
if (c(TRUE, FALSE)) {}
if (NA) {}
#Condições inválidas
if (c(TRUE, FALSE)) {}
if (NA) {}
identical(0L, 0)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
# Execução condicional ----------------------------------------------------
has_name <- function(x) {
nms <- names(x)
if (is.null(nms)) {
rep(FALSE, length(x))
} else {
!is.na(nms) && nms != ""
}
}
x <- c(1,2,3)
has_name(x)
y <- tribble(
~col1, ~col2, ~col3,
#----/------/-------
1, 2, 3,
2, 3, 4,
3, 4, 5
)
y <- tibble::tribble(
~col1, ~col2, ~col3,
#----/------/-------
1, 2, 3,
2, 3, 4,
3, 4, 5
)
y
has_name(y)
names(x)
names(y)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
has_name(y)
#Condições inválidas
if (c(TRUE, FALSE)) {}
if (NA) {}
identical(0L, 0)
switch (op,
plus = x + y,
minuts = x - y,
stop("Operação desconhecida")
)
#Múltiplas condições
op <- "plus"
opr <- function(x, y, op){
switch (op,
plus = x + y,
minuts = x - y,
stop("Operação desconhecida")
)
}
opr(x,y,op)
a <- 2
b <- 2
opr(a,b,op)
opr(a,b,"minuts")
opr(a,b,"minus")
opr <- function(x, y, op){
switch (op,
plus = x + y,
minus = x - y,
stop("Operação desconhecida")
)
}
a <- 2
b <- 2
opr(a,b,op)
opr(a,b,"minus")
opr <- function(x, y, op){
switch (op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y
stop("Operação desconhecida")
a <- 2
b <- 2
opr <- function(x, y, op){
switch (op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Operação desconhecida")
)
}
opr(a,b,op)
opr(a,b,"minus")
opr(a,b,times)
opr(a,b,"times")
opr(a,b,"divide")
oper(10,7,"minus")
opr(10,7,"minus")
opr(10,7,"times")
rm(op)
opr <- function(x, y, op="plus"){
switch (op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Operação desconhecida")
)
}
a <- 2
b <- 2
opr(a,b)
opr(a,b,"minus")
opr(a,b,"times")
opr(a,b,"divide")
opr(10,7,"minus")
opr(10,7,"times")
opr(10,7,"plus")
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R")
# Argumentos de funções ----------------------------------------------------
mean_c <- function(x, conf = 0.95) {
se <- sd(x) / sqrt(length(x))
alpha <- 1 - conf
mean(x) + se * qnorm(c(alpah / 2, 1 - alpha / 2))
}
x <- runif(100)
?runif
plot(x)
mean_c(x)
# Argumentos de funções ----------------------------------------------------
mean_c <- function(x, conf = 0.95) {
se <- sd(x) / sqrt(length(x))
alpha <- 1 - conf
mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}
mean_c(x)
mean_c(x, 0.99)
x
hist(x)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean <- function(x, w) {
if (length(x) != length(w)) {
stop("x and w must be the same length", call. = FALSE)
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:3)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(y))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:3, na.rm = "ERRO")
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:6, na.rm = "ERRO")
wt_mean(1:6, 1:3, na.rm = TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:6, na.rm = "ERRO")
wt_mean(1:6, 1:3, na.rm = TRUE)
wt_mean(c(2,2,NA,3,3), 1:5)
wt_mean(c(2,2,NA,3,3), 1:5, na.rm = TRUE) #Funciona
wt_mean(1:6, 1:6, na.rm = "ERRO") #Erro aciona gatilho para exceção
wt_mean(1:6, 1:3, na.rm = TRUE) #Erro aciona gatilho para exceção
show_missings <- function(df) {
n <- sum(is.na(df))
cat("Missing values: ", n, "\n", sep = "")
invisible(df)
}
x <- show_missings(mtcars)
x
class(x)
dim(x)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
library(tidyverse)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean(1:6, 1:3) #Erro aciona gatilho para exceção
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6) #Funciona
wt_mean(c(2,2,NA,3,3), 1:5) #Funciona, mas retorna NA
wt_mean(c(2,2,NA,3,3), 1:5, na.rm = TRUE) #Funciona
wt_mean(1:6, 1:6, na.rm = "ERRO") #Erro aciona gatilho para exceção
wt_mean(1:6, 1:3, na.rm = TRUE) #Erro aciona gatilho para exceção
show_missings <- function(df) {
n <- sum(is.na(df))
cat("Missing values: ", n, "\n", sep = "")
invisible(df)
}
x <- show_missings(mtcars)
class(x)
dim(x)
library(tidyverse)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
