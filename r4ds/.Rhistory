df %>%
filter(name == "Mary") %>%
mutate(age = 27)
?where
df$age
vs <- list(
c(1,3,5),
c(1,3,5,7),
c(1,3,5,7,9)
)
vs
vs %>% reduce(intersect)
df
df[2]
df[name=="Mary",]
df[name=="Mary"]
df
df$name == Mary
df$name == "Mary"
df[TRUE]
df[df$name == "Mary"]
df[df$name == "Mary", age]
filter(df, name=="Mary")
filter(df, name=="Mary")$age
filter(df, name=="Mary")$age = 27
filter(df, name=="Mary")$age
uptade(df)
?update
?diplyr::update
library(nycflights13)
library(tidyverse)
?flights
#SALVANDO CONJUNTO DE DADOS CSV
#Ação não relacionada ao estudo. Gravando apenas para uso posterior em Python
#arquivo = ("D:\\git\\python.ds\\data\\flights.csv")
#write.table(flights, file=arquivo, row.names=FALSE, quote=FALSE, sep=",")
View(flights)
#====================================
##Operação de filtro
#====================================
filter(flights,
month == 1,
day == 1)
jan1 <- filter(flights,
month == 1,
day == 1)
#Operação com OR
filter(flights,
month == 11 | month ==12)
filter(flights,
month %in% c(11,12))
#Operação combinadas
filter(flights,
!(arr_delay > 120 | dep_delay > 120)) #Voos sem atraso maior que 120 na chegada ou partida
#Valores faltantes
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df,
is.na(x) | x > 1)
##====================
##EXERCÍCIOS
##====================
#* Atraso maior ou igual a 2 horas na checaga
filter(flights,
dep_delay >= 120)
#* Foram para Houston (IAH ou HOU)
houston <- filter(flights,
dest == "IAH" | dest == "HOU")
#* Foram operadorados pela United, American ou Delta
companies <- filter(flights,
carrier %in% c("AA", "UA", "DL"))
#* Partiram em julho, agosto ou setembro
filter(flights,
month %in% c(7, 8, 9))
#* Chegaram com mais de duas horas de atraso, mas não saíram atrasado
filter(flights,
arr_delay >= 120 & dep_delay <= 0)
#* Atrasaram mais de uma hora, mas compensaram mais de 30 minutos no trajeto
filter(flights,
dep_delay > 60 & arr_delay < 30)
#* Saíram entre meia noite e 6
madrugada <- filter(flights,
dep_time >= 2400 | dep_time <= 600)
#* Uso between
#* dep_time faltante
filter(flights,
is.na(dep_time))
summary(flights)
#*
#*
##====================
##Ordenar linhas
##====================
#Ascendente
arrange(flights,
year, month, day)
#Descendente
arrange(flights,
desc(arr_delay))
#Ordenação com valores faltantes
df <- tibble(x = c(5, NA, 2))
arrange(df, x)
arrange(df, desc(x))
##====================
##EXERCÍCIOS
##====================
#* NA
#* Voos mais atrasados e voos que sairam mais cedo
arrange(flights,
desc(dep_delay))
arrange(flights,
dep_delay)
#* Voos mais rápidos
arrange(flights,
air_time)
##====================
##Selecionar colunas
##====================
select(flights,
year, month, day)
#Aninhando operações
arrange(select(flights, air_time),
air_time)
#Seleção de intervalo
select(flights,
year:day)
#Seleção por exclusão de colunas
df <- select(flights,
-(year:day))
rename(flights,
tail_num = tailnum)
select(flights,
time_hour, air_time, #Coloca a selação no início da tabela
everything()) #Mantém todas as demais colunas após a seleção
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights,
one_of(vars))
select(flights,
contains("delay"))
select(flights,
contains("TIME"))
##================================
##Adicionando colunas calculadas
##================================
flights_sml <- select(flights,
year:day,
ends_with("delay"),
distance,
air_time)
View(flights_sml)
mutate(flights_sml,
gain = arr_delay - dep_delay,
speed = distance / air_time * 60)
#Referência a colunas criadas na mesma operação mutate
flights_sml <- mutate(flights_sml,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours)
#Mantendo apenas colunas criadas na operação
transmute(flights_sml,
gain = arr_delay - dep_delay,
hours = air_time / 60,
gain_per_hour = gain / hours)
##================================
##Funções e operações úteis
##================================
#Operação entre vetores e escalares
x <- c(1,2,3,4)
x / sum(x)
x - mean(x)
x + x**2
#Aritmética modular
transmute(flights,
hour = dep_time %/% 100,
minute = dep_time %% 100)
4317+343
4660+400
5060-2800
source("D:/GitHub/rDS/r4ds/rds_cap18_modelos_basico.R", echo=TRUE)
#Visualização básica dos dados de exemplo
ggplot(sim1, aes(x,y)) +
geom_point()
#Observar como modelos lineares aleatórios se ajustam aos dados
models <- tibble(
a1 = runif(250, -20, 40),
a2 = runif(250, -5, 5)
)
models
ggplot(sim1, aes(x, y)) +
geom_abline(
aes(intercept = a1, slope = a2),
data = models, alpha = 1/4
) +
geom_point()
#Função calcula modelo
model <- function(a, data) {
a[1] + data$x * a[2]
}
model
model(c(7, 1.5), sim1)
#Cálculo da distância entre previsão e real baseado em RMSE
measure_distance <- function(mod, data) {
diff <- data$y - model(mod, data)
sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
#Avaliar os diversos modelos aleatórios
sim1_dist <- function(a1, a2) {
measure_distance(c(a1,a2), sim1)
}
models <- models %>%
mutate(dist = purr::map2_dbl(a1, a2, sim1_dist))
models <- models %>%
mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models
#Visualização dos melhores modelos (menor RMSE)
ggplot(sim1, aes(x,y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(
aes(intercept = a1, slope = a2, color = -dist),
data = filter(models, rank(dist) <= 10)
)
ggplot(models, aes(a1, a2)) +
geom_point(
size = 4, color = "red"
) +
geom_point(aes(colour = -dist))
ggplot(models, aes(a1, a2)) +
geom_point(
data = filter(models, rank(dist) <= 10),
size = 4, color = "red"
) +
geom_point(aes(colour = -dist))
#Busca em grade de modelos
grid <- expand.grid(
a1 = seq(-5, 20, length = 25),
a2 = seq(1, 3, length = 25)
) %>%
mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
grid
View(grid)
#Visualização de melhores modelos dentro do grid
grid %>%
ggplot(aes(a1, a2)) +
geom_point(
datra = filter(grid, rank(dist) <= 10),
size = 4, colour = "red"
) +
geom_point(aes(color = -dist))
#Visualização de melhores modelos dentro do grid
grid %>%
ggplot(aes(a1, a2)) +
geom_point(
data = filter(grid, rank(dist) <= 10),
size = 4, colour = "red"
) +
geom_point(aes(color = -dist))
#Visualização dos modelos gerados por grid
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(
aes(intercept = a1, slope = a2, color = -dist),
data = filter(grid, rank(dist) <= 10)
)
#Otimização para encontrar modelo adequado
best <- optim(c(0, 0), measure_distance, data = sim1)
best$par
best
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(intercept = best$par[1], slope = best$par[2])
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(intercept = best$par[1], slope = best$par[2], color = "red")
best$par
#Modelagem usando ferramenta lm
sim1_mod <- lm(y ~ x, data = sim1)
coef(sim1_mod)
sim1_mod$coefficients
sim1_mod$coefficients[1]
sim1_mod$coefficients[2]
coef(sim1_mod)
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(sim1_mod)
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(sim1_mod$coefficients[1], sim1_mod$coefficients[2])
lm
sim1_mod
sim1_mod$coefficients
sim1_mod$coefficients[1]
source("D:/GitHub/rDS/r4ds/rds_cap18_modelos_basico.R", echo=TRUE)
best$par
coef(sim1_mod)
?geom_abline
cf <- coef(sim1_mod)
cf
class(cf)
cf <- list(coef(sim1_mod))
cf
as.list(coef(sim1_mod))
cf <- as.list(coef(sim1_mod))
cf
cf$`(Intercept)`
cf[1]
cf[[1]]
ggplot(sim1, aes(x, y)) +
geom_point(size = 2, color = "grey30") +
geom_abline(intercept = as.list(coef(sim1_mod))[[1]],
slope = as.list(coef(sim1_mod))[[2]],
color = "blue")
library(tidyverse)
library(modelr)
library(tidyverse)
library(modelr)
options(na.action = na.warn)
grid <- sim1 %>%
data_grid(x)
View(grid)
sim1_mod <- lm(y ~ x, data = sim1)
grid <- grid %>%
add_predictions(sim1_mod)
View(grid)
source("D:/GitHub/rDS/r4ds/rds_cap18_modelos_prev.R", echo=TRUE)
sim1
View(sim1)
View(grid)
View(grid)
#Visualização
ggplot(sim1, aes(x)) +
geom_point(aes(y = y)) +
geom_line(
aes(y = pred),
data = grid,
color = "red",
size = 1
)
#Adicionando resíduos do modelo
sim1 <- sim1 %>%
add_residuals(sim1_mod)
sim1
#Visualização dos resíduos
ggplot(sim1, aes(resid)) +
geom_freqpoly(binwidth = 0.5)
ggplot(sim1, aes(x, resid)) +
geom_ref_line(h = 0) +
geom_point()
source("D:/GitHub/rDS/r4ds/rds_cap18_modelos_prev.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap18_modelos_prev.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap18_modelos_prev.R", echo=TRUE)
#Bibliotecas e configuração NA
library(tidyverse)
library(modelr)
options(na.action = na.warn)
library(lubridate)
#Datasets
library(nycflights13)
ggplot(diamonds, aes(cut, price)) + geom_boxplot()
ggplot(diamonds, aes(color, price)) + geom_boxplot()
ggplot(diamonds, aes(clarity, price)) + geom_boxplot()
source("D:/GitHub/rDS/r4ds/rds_cap19_modelos_constr.R", echo=TRUE)
#Peso e quilates
ggplot(diamonds, aes(carat, price)) +
geom_hex(bins = 50)
#Transformações
diamonds2 <- diamonds %>%
#Menor ou igual a 2 quilates
filter(carat <= 2.5) %>%
#Mapamento de variáveis log de preço e quilates
mutate(lprice = log2(price), lcarat = log2(carat))
#Visualização com dataset transformado
ggplot(diamonds2, aes(lcarat, lprice)) +
geom_hex(bins = 50)
#Modelagem
mod_diamonds <- lm(lprice ~ lcarat, data = diamonds2)
mod_diamonds
#Análise do modelo
grid <- diamonds2 %>%
data_grid(carat = seq_range(carat, 20)) %>%
mutate(lcarat = log2(carat)) %>%
add_predictions(mod_diamond, "lprice") %>%
mutate(price = 2 ^ lprice)
#Análise do modelo
grid <- diamonds2 %>%
data_grid(carat = seq_range(carat, 20)) %>%
mutate(lcarat = log2(carat)) %>%
add_predictions(mod_diamonds, "lprice") %>%
mutate(price = 2 ^ lprice)
grid
#Visualização das predições
ggplot(diamonds2, aes(carat, price)) +
geom_hex(bins = 50) +
geom_line(data = grid, color = "red", size = 1)
head(mpg)
ggplot(mpg, aes(hwy, disp)) +
geom_hex(bins = 10)
ggplot(mpg, aes(hwy, displ)) +
geom_hex(bins = 10)
ggplot(mpg, aes(hwy, displ)) +
geom_hex(bins = 50)
ggplot(mpg, aes(hwy, displ)) +
geom_hex(bins = 30)
ggplot(mpg, aes(hwy, displ)) +
geom_hex(bins = 20)
ggplot(mpg, aes(hwy, displ)) +
geom_hex(bins = 20)
mpg2
mpg
mpg2 <- mpg %>%
mutate(lhwy = log2(hwy), ldispl = log2(ldispl))
mpg2 <- mpg %>%
mutate(lhwy = log2(hwy), ldispl = log2(displ))
head(mpg2)
ggplot(mpg, aes(lhwy, ldispl)) +
geom_hex(bins = 20)
ggplot(mpg2, aes(lhwy, ldispl)) +
geom_hex(bins = 20)
?scale
mpg2 <- mpg %>%
mutate(lhwy = log2(hwy), ldispl = log2(displ),
zhwy = scale(hwy), zdispl = scale(displ))
head(mpg2)
View(mpg2)
ggplot(mpg2, aes(lhwy, ldispl)) +
geom_hex(bins = 20)
#Visualização com padronização z-score
ggplot(mpg2, aes(zhwy, zdispl)) +
geom_hex(bins = 20)
source("D:/GitHub/rDS/r4ds/rds_cap19_modelos_constr.R", echo=TRUE)
model <- lm(lhwy ~ ldispl, data = mp2)
model <- lm(lhwy ~ ldispl, data = mpg2)
model
grid_mpg <- mpg2 %>%
data_grid(displ = seq_range(displ, 20))
grid_mpg
grid_mpg <- mpg2 %>%
data_grid(displ = seq_range(displ, 20)) %>%
mutate(ldispl = log2(ldisp))
grid_mpg <- mpg2 %>%
data_grid(displ = seq_range(displ, 20)) %>%
mutate(ldispl = log2(disp))
grid_mpg <- mpg2 %>%
data_grid(displ = seq_range(displ, 20)) %>%
mutate(ldispl = log2(displ))
grid_mpg
grid_mpg <- mpg2 %>%
data_grid(displ = seq_range(displ, 20)) %>%
mutate(ldispl = log2(displ)) %>%
add_predictions(model, "lhwy")
grid_mpg
grid_mpg <- mpg2 %>%
data_grid(displ = seq_range(displ, 20)) %>%
mutate(ldispl = log2(displ)) %>%
add_predictions(model, "lhwy") %>%
mutate(hwy = 2 ^ lhwy)
grid_mpg
#Visualização das predições
ggplot(mpg2, aes(displ, hwy)) +
geom_hex(bins = 20) +
geom_line(data = grid_mpg, color = "red", size = 1)
source("D:/GitHub/rDS/r4ds/rds_cap19_modelos_constr.R", echo=TRUE)
diamonds2 <- diamonds2 %>%
add_residuals(mod_diamonds, "lresid")
ggplot(diamonds2, aes(lcaret, lresid)) +
geom_hex(bins = 50)
ggplot(diamonds2, aes(lcarat, lresid)) +
geom_hex(bins = 50)
ggplot(diamonds2, aes(cut, lresid)) + geom_boxplot()
ggplot(diamonds2, aes(color, lresid)) + geom_boxplot()
ggplot(diamonds2, aes(clarity, lresid)) + geom_boxplot()
#Adição de novas variáveis no modelo
mod_diamonds2 <- lm(
lprice ~ lcarat + color + cut + clarity,
data = diamonds2
)
mod_diamonds2
grid <- diamonds2 %>%
data_grid(cut, .model = mod_diamonds2)
grid
grid <- diamonds2 %>%
data_grid(cut, .model = mod_diamonds2) %>%
add_predictions(mod_diamonds2)
grid
ggplot(grid, aes(cut, pred)) +
geom_point()
diamonds2 <- diamonds2 %>%
add_residuals(mod_diamonds2, "lresid2")
ggplot(diamonds2, aes(lcarat, lresid2)) +
geom_hex(bins = 50)
#Valores incomuns
diamonds2 %>%
filter(abs(lresid2) > 1) %>%
add_predictions(mod_diamonds2) %>%
mutate(pred = round(2 ^ pred)) %>%
select(price, pred, carat::table, x:z) %>%
arrange(price)
install.packages("carat")
#Valores incomuns
diamonds2 %>%
filter(abs(lresid2) > 1) %>%
add_predictions(mod_diamonds2) %>%
mutate(pred = round(2 ^ pred)) %>%
select(price, pred, carat::table, x:z) %>%
arrange(price)
#Valores incomuns
diamonds2 %>%
filter(abs(lresid2) > 1) %>%
add_predictions(mod_diamonds2) %>%
mutate(pred = round(2 ^ pred)) %>%
select(price, pred, carat:table, x:z) %>%
arrange(price)
