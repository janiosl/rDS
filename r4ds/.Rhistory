days(7)
months(1:6)
weeks(3)
years(1)
years(1.5)
#Operações com períodos
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)
#Aplicando ao dataset de voos
flights_dt %>%
filter(arr_time < dep_time)
flights_dt
View(flights_dt)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
flights_dt %>%
filter(overnight, arr_time < dep_time)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap13_datas_estudoCaso.R", echo=TRUE)
#Intervalos
dyears(1) / ddays(365)
years(1) / days(1)
next_year <- today() + years(1)
next_year
(today() %--% next_year) / ddays(1)
(today() %--% next_year) / days(1)
(today() %--% next_year) %/% days(1)
length(OlsonNames())
library(magrittr)
foo_foo <- litle_bunny()
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
dplyr::mutate(price_per_carat = price / carat)
pryr::object_size(diamonds)
install.packages("pryr")
#install.packages("pryr")
pryr::object_size(diamonds)
pryr::object_size(diamonds2)
pryr::object_size(diamonds, diamonds2)
View(diamonds)
View(diamonds2)
diamonds$carat[1] <- NA
#install.packages("pryr")
pryr::object_size(diamonds)
pryr::object_size(diamonds2)
pryr::object_size(diamonds, diamonds2)
##Problema no uso de pipe
#Funções que usam ambiente temporário
assign(x, 10)
##Problema no uso de pipe
#Funções que usam ambiente temporário
assign("x", 10)
x
"x" %>% assign(100)
x
#Definição explícita do ambiente
env <- environment()
"x" <- assign(100)
x
"x" <- assign(100, envir = env)
"x" %>% assign(100, envir = env)
x
#Funções com lazy evaluation
tryCatch(stop("!"), error = function(e) "An error")
stop("!") %>%
tryCatch(error = function(e) "An error")
stop("!") %>%
tryCatch(error = function(e) "An error")
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnomr(100)
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100)
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100) %>%
matrix(ncol = 2)
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100) %>%
matrix(ncol = 2) %>%
plot()
#Uso de Tee para retornar valores intermediários
#Com pipe %>%
rnorm(100) %>%
matrix(ncol = 2) %>%
plot() %>%
str()
#Com Tee %T%
rnorm(100) %>%
matrix(ncol = 2) %T%
plot() %>%
str()
#Com Tee %T%
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot() %>%
str()
?cor
mtcars %$%
cor(disp, mpg)
#Atribuição direta
#Explícita
mtcars <- mtcars %>%
transform(cyl = cyl * 2)
mtcars
#Direta (implícita)
mtcars %<>% transform(cyl = cyl * 2)
mtcars
source("D:/GitHub/rDS/r4ds/rds_cap14_pipes.R", echo=TRUE)
View(mtcars)
source("D:/GitHub/rDS/r4ds/rds_cap14_pipes.R", echo=TRUE)
df <- tibble::tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
df
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
View(df)
#Reescalar uma coluna para rage 0 a 1
df$a <- (df$a - min(df$a, na.rm = TRUE)) /
(max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df
##Abordagem usando função
rescale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
rescale01(df$a)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
df$b_ <- rescale01(df$b)
df
df$c_ <- rescale01(df$c)
df$d_ <- rescale01(df$d)
df
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
#Correção de erros uma única vez
x <- c(1:1), Inf
#Correção de erros uma única vez
x <- c(1:10, Inf)
x
rescale01(x)
##Abordagem usando função
rescale01 <- function(x) {
#Sem tratamento de infinito
#rng <- range(x, na.rm = TRUE)
#Com tratamento de infinito
rng <- range(x, na.rm = TRUE, finite = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
#Repetição após tratamento do erro na função
rescale01(x)
?'if'
if (c(TRUE, FALSE)) {}
if (NA) {}
#Condições inválidas
if (c(TRUE, FALSE)) {}
if (NA) {}
identical(0L, 0)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
# Execução condicional ----------------------------------------------------
has_name <- function(x) {
nms <- names(x)
if (is.null(nms)) {
rep(FALSE, length(x))
} else {
!is.na(nms) && nms != ""
}
}
x <- c(1,2,3)
has_name(x)
y <- tribble(
~col1, ~col2, ~col3,
#----/------/-------
1, 2, 3,
2, 3, 4,
3, 4, 5
)
y <- tibble::tribble(
~col1, ~col2, ~col3,
#----/------/-------
1, 2, 3,
2, 3, 4,
3, 4, 5
)
y
has_name(y)
names(x)
names(y)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
has_name(y)
#Condições inválidas
if (c(TRUE, FALSE)) {}
if (NA) {}
identical(0L, 0)
switch (op,
plus = x + y,
minuts = x - y,
stop("Operação desconhecida")
)
#Múltiplas condições
op <- "plus"
opr <- function(x, y, op){
switch (op,
plus = x + y,
minuts = x - y,
stop("Operação desconhecida")
)
}
opr(x,y,op)
a <- 2
b <- 2
opr(a,b,op)
opr(a,b,"minuts")
opr(a,b,"minus")
opr <- function(x, y, op){
switch (op,
plus = x + y,
minus = x - y,
stop("Operação desconhecida")
)
}
a <- 2
b <- 2
opr(a,b,op)
opr(a,b,"minus")
opr <- function(x, y, op){
switch (op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y
stop("Operação desconhecida")
a <- 2
b <- 2
opr <- function(x, y, op){
switch (op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Operação desconhecida")
)
}
opr(a,b,op)
opr(a,b,"minus")
opr(a,b,times)
opr(a,b,"times")
opr(a,b,"divide")
oper(10,7,"minus")
opr(10,7,"minus")
opr(10,7,"times")
rm(op)
opr <- function(x, y, op="plus"){
switch (op,
plus = x + y,
minus = x - y,
times = x * y,
divide = x / y,
stop("Operação desconhecida")
)
}
a <- 2
b <- 2
opr(a,b)
opr(a,b,"minus")
opr(a,b,"times")
opr(a,b,"divide")
opr(10,7,"minus")
opr(10,7,"times")
opr(10,7,"plus")
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R")
# Argumentos de funções ----------------------------------------------------
mean_c <- function(x, conf = 0.95) {
se <- sd(x) / sqrt(length(x))
alpha <- 1 - conf
mean(x) + se * qnorm(c(alpah / 2, 1 - alpha / 2))
}
x <- runif(100)
?runif
plot(x)
mean_c(x)
# Argumentos de funções ----------------------------------------------------
mean_c <- function(x, conf = 0.95) {
se <- sd(x) / sqrt(length(x))
alpha <- 1 - conf
mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}
mean_c(x)
mean_c(x, 0.99)
x
hist(x)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean <- function(x, w) {
if (length(x) != length(w)) {
stop("x and w must be the same length", call. = FALSE)
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:3)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(y))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:3, na.rm = "ERRO")
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:6, na.rm = "ERRO")
wt_mean(1:6, 1:3, na.rm = TRUE)
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6)
wt_mean(1:6, 1:6, na.rm = "ERRO")
wt_mean(1:6, 1:3, na.rm = TRUE)
wt_mean(c(2,2,NA,3,3), 1:5)
wt_mean(c(2,2,NA,3,3), 1:5, na.rm = TRUE) #Funciona
wt_mean(1:6, 1:6, na.rm = "ERRO") #Erro aciona gatilho para exceção
wt_mean(1:6, 1:3, na.rm = TRUE) #Erro aciona gatilho para exceção
show_missings <- function(df) {
n <- sum(is.na(df))
cat("Missing values: ", n, "\n", sep = "")
invisible(df)
}
x <- show_missings(mtcars)
x
class(x)
dim(x)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
library(tidyverse)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean(1:6, 1:3) #Erro aciona gatilho para exceção
wt_mean <- function(x, w, na.rm = FALSE) {
stopifnot(is.logical(na.rm), length(na.rm) == 1)
stopifnot(length(x) == length(w))
if (na.rm) {
miss <- is.na(x) | is.na(w)
x <- x[!miss]
w <- w[!miss]
}
sum(w * x) / sum(x)
}
wt_mean(1:6, 1:6) #Funciona
wt_mean(c(2,2,NA,3,3), 1:5) #Funciona, mas retorna NA
wt_mean(c(2,2,NA,3,3), 1:5, na.rm = TRUE) #Funciona
wt_mean(1:6, 1:6, na.rm = "ERRO") #Erro aciona gatilho para exceção
wt_mean(1:6, 1:3, na.rm = TRUE) #Erro aciona gatilho para exceção
show_missings <- function(df) {
n <- sum(is.na(df))
cat("Missing values: ", n, "\n", sep = "")
invisible(df)
}
x <- show_missings(mtcars)
class(x)
dim(x)
library(tidyverse)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
9172.22+925.6
10097.82+1341.74
source("D:/GitHub/rDS/r4ds/rds_cap15_funcs.R", echo=TRUE)
wt_mean(1:6, 1:6) #Funciona
wt_mean(c(2,2,NA,3,3), 1:5) #Funciona, mas retorna NA
wt_mean(c(2,2,NA,3,3), 1:5, na.rm = TRUE) #Funciona
wt_mean(1:6, 1:6, na.rm = "ERRO") #Erro aciona gatilho para exceção
wt_mean(1:6, 1:3, na.rm = TRUE) #Erro aciona gatilho para exceção
show_missings <- function(df) {
n <- sum(is.na(df))
cat("Missing values: ", n, "\n", sep = "")
invisible(df)
}
x <- show_missings(mtcars)
class(x)
dim(x)
library(tidyverse)
mtcars %>%
show_missings() %>%
mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
show_missings()
library(tidyverse)
typeof(letters)
typeof(1:10)
typeof(letters)
typeof(1:10)
##Tamanho
x <- list("a", "b", 1:10)
length(x)
x
y <- c(1:10)
y
length(y)
1:10 %% 3
1:10 %% 3 == 0
#Manual
c(TRUE, TRUE, FALSE, NA)
v <- c(1,2,3,4,5,6,NA,8)
V
v
v == 0
v > 3
v <- c(1,2,3,4,5,6,NA,8)
v
vl <- v > 3
vl
#Vetor numérico
typeof(1)
typeof(1L)
typeof(0.5)
x <- sqrt(2) ^ 2
x
x - 2
x == 2
near(x, 2)
near(x, 3)
source("D:/GitHub/rDS/r4ds/rds_cap16_vetores.R", echo=TRUE)
c(*1, 0, 1) / 0
#Valores especiais
c(-1, 0, 1) / 0
is.finite(y)
is.infinite(y)
y
#Operações lógicas com valores especiais
y = c(0, Inf, -Inf, NA, NaN)
y
is.finite(y)
is.infinite(y)
is.na(y)
is.nan(y)
source("D:/GitHub/rDS/r4ds/rds_cap16_vetores.R", echo=TRUE)
#Conversão
as.integer(c(TRUE, FALSE, FALSE, TRUE))
as.logical(c(1,0,0,1))
as.logical(c(1,0,0,1,3))
as.logical(c(1,0,0,1,3,-1,0))
x <- sample(20,, 100, replace = TRUE)
x <- sample(20, 100, replace = TRUE)
x
y <- x > 10
y
sum(y)
mean(y)
#Operações entre vetores e escalares
#Não há escalar real no R, por isso as operações são naturalmente vetorizadas
sample(10) + 100
sample(10)
#Operações entre vetores e escalares
#Não há escalar real no R, por isso as operações são naturalmente vetorizadas
v <- sample(10)
v
v + 100
v <- runif(10)
v
v > 0.5
v1 <- sample(10)
v2 <- sample(10)
v1
v2
v1 + v2
1:10
1:2
1:10 + 1:2
1:10 + 1:3
#Reciclagem
tibble(x = 1:4, y = 1:2)
tibble(x = 1:4, y = rep(1:2, 2))
tibble(x = 1:4, each(1:2, 2))
tibble(x = 1:4, y= each(1:2, 2))
tibble(x = 1:4, y = rep(1:2, each = 2))
